# -*- coding: utf-8 -*-
"""IC_MapasPrecipitacao

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1Xcx12qHp1VtsLKk68HPmXkcZnUei5iKo
"""

# Bibliotecas Utilizadas

!pip install -U plotly
import plotly
! pip install geopandas
import pandas as pd
import geopandas as gpd
import plotly.express as px
import plotly.graph_objects as go
import numpy as np

# Preparando o ambiente no Google Drive:

#importando a biblioteca
from google.colab import drive

# Isso irá pedir sua autorização
drive.mount('/content/drive')

# Agora, seu Drive estará disponível em: /content/drive/My Drive

# importando o banco da precipitação
bancoPrecipitacao = pd.read_csv('/content/drive/My Drive/BD_1998_2020_meso.csv',sep=",")

# importando o shape de mesorregioes
mesorregioes=gpd.read_file('/content/drive/My Drive/PE_Mesorregioes_2019.shp')

# importando o geohson de mesorregioes
mesorregioes_=gpd.read_file('/content/drive/My Drive/PE_Mesorregioes_2019.geojson')


# importando o shape das quadriculas
quadricula_=gpd.read_file('/content/drive/My Drive/quadricula_meso.shp')

quadricula_

# Função para fazer o join entre o banco de precipitacoes e o shape das quadriculas
def join_df_to_shp(bancoPrecipitacao,ano, gpd_gdf):

    # Prepara a coluna da precipitação
    (bancoPrecipitacao[(bancoPrecipitacao['ANO'] ==ano)].groupby(by=['codigo','ANO']).sum().groupby(level=[0]).cumsum()/12).to_csv('/content/drive/My Drive/desenvolvimento/'+str(ano)+'.csv')
    bancoPrecipitacaoColunas = pd.read_csv('/content/drive/My Drive/desenvolvimento/'+str(ano)+'.csv',sep=",")
    """"""
    df_ = pd.merge(bancoPrecipitacaoColunas, gpd_gdf[['CODIGO','geometry']], left_on='codigo', right_on='CODIGO', how='left')

    # DROP the NI counties
    df_ = df_.dropna(subset=['geometry'])

    # convert back to a geopandas object (for ease of plotting etc.)
    crs = {'init': 'epsg:4326'}
    gdf_ = gpd.GeoDataFrame(df_, crs=crs, geometry='geometry')
    # remove the extra area_code column joined from gdf
    gdf_.drop('codigo',axis=1, inplace=True)

    return gdf_

pop_gdf = join_df_to_shp(bancoPrecipitacao,1999, quadricula_)



pop_gdf["PRECIPITACAO"].max()

pop_gdf

listaMin=[]
listaMax=[]
for i in range(1998,2021,1):
  banco=join_df_to_shp(bancoPrecipitacao,i, quadricula_)
  listaMin.append(banco["PRECIPITACAO"].min())
  listaMax.append(banco["PRECIPITACAO"].max())

listaMin

max(listaMax)

for i in range(1998,2021,1):
  print(i)

merged.index

# Mapa final
merged = join_df_to_shp(bancoPrecipitacao,2020, quadricula_)
fig = px.choropleth(merged, geojson=merged.geometry,
                    locations=merged.index, 
                    color = "PRECIPITACAO",
                    range_color=(9.983109881480537, 240.69547843933103),
                    color_continuous_scale="blues")
                    #height=500,
#fig.update_traces(geojson=mesorregioes_, selector=dict(type='choropleth'))
fig.update_geos(fitbounds="locations")#, visible=True)
fig.update_layout(
    title_text='1998'
)
fig.update(layout = dict(title=dict(x=1)))
fig.update_layout(
    margin={"r":0,"t":30,"l":10,"b":10},
    coloraxis_colorbar={
        'title':'Precipitação Média'})

fig.update_traces(marker_line_color="black", selector=dict(type='choropleth'))

fig.show()

! pip install geojson
import geojson
with open('/content/drive/My Drive/PE_Mesorregioes_2019.geojson') as f:
    gj = geojson.load(f)
mesorregioes_ = gj['features'][0]

filtrandoMesoEMes(bancoPrecipitacao,"Sertão Pernambucano",1)["PRECIPITACAO"].mean()





# Gerando a base mensal por meso

def filtrandoMesoEAno(df,meso,ano):
  df_meso=df.loc[df['MESO_'] == meso]
  df_ano=df_meso.loc[df_meso["ANO"] == ano]

  return df_ano

filtrandoMesoEAno(bancoPrecipitacao,"Sertão Pernambucano",1998)

# Gerando a base mensal por meso

def filtrandoMesoEMes(df,meso,mes):
  df_meso=df.loc[df['MESO_'] == meso]
  df_mes=df_meso.loc[df_meso["MES"] == mes]

  return df_mes



# Gerando gráficos para casas que tem 1 quarto
trace1 = go.Box(y = filtrandoMesoEMes(bancoPrecipitacao,"Sertão Pernambucano",1)["PRECIPITACAO"],
                name = 'Janeiro',
                marker = {'color': '#e41a1c'})

data = [trace1]
layout = go.Layout(title = 'Dispersão da precipitação para as mesorregiões de Pernambuco (1998-2020)',
                   titlefont = {'family': 'Arial',
                                'size': 22,
                                'color': '#7f7f7f'},
                   xaxis = {'title': 'Mesorregiões'},
                   yaxis = {'title': 'Precipitação (mm)'},
                   paper_bgcolor = 'rgb(243, 243, 243)',
                   plot_bgcolor = 'rgb(243, 243, 243)')
fig = go.Figure(data=data, layout=layout)
#py.iplot(fig)
fig.show()

color_discrete_sequence=px.colors.qualitative.G10


# Gerando gráficos para casas que tem 1 quarto
trace1 = go.Box(y = bancoPrecipitacao.loc[bancoPrecipitacao['MESO_'] == "Sertão Pernambucano", 'PRECIPITACAO'],
                name = 'Sertão Pernambucano',
                marker = {'color': '#e41a1c'})
# Gráfico de caixa para casas com 2 quartos
trace2 = go.Box(y = bancoPrecipitacao.loc[bancoPrecipitacao['MESO_'] == "São Francisco Pernambucano", 'PRECIPITACAO'],
                name = 'São Francisco Pernambucano',
                marker = {'color': '#377eb8'})
# Gráfico de caixa para casas com 3 quartos
trace3 = go.Box(y = bancoPrecipitacao.loc[bancoPrecipitacao['MESO_'] == "Metropolitana do Recife", 'PRECIPITACAO'],
                name = 'Metropolitana do Recife',
                marker = {'color': '#4daf4a'})
# Gráfico para casas de quatro quartos
trace4 = go.Box(y = bancoPrecipitacao.loc[bancoPrecipitacao['MESO_'] == "Agreste Pernambucano", 'PRECIPITACAO'],
                name = 'Agreste Pernambucano',
                marker = {'color': '#984ea3'})
# Gráfico para casas de quatro quartos
trace5 = go.Box(y = bancoPrecipitacao.loc[bancoPrecipitacao['MESO_'] == "Mata Pernambucana", 'PRECIPITACAO'],
                name = 'Mata Pernambucana',
                marker = {'color': '#ff7f00'})
data = [trace1, trace2, trace3, trace4, trace5]
layout = go.Layout(title = 'Dispersão da precipitação para as mesorregiões de Pernambuco (1998-2020)',
                   titlefont = {'family': 'Arial',
                                'size': 22,
                                'color': '#7f7f7f'},
                   xaxis = {'title': 'Mesorregiões'},
                   yaxis = {'title': 'Precipitação (mm)'},
                   paper_bgcolor = 'rgb(243, 243, 243)',
                   plot_bgcolor = 'rgb(243, 243, 243)')
fig = go.Figure(data=data, layout=layout)
#py.iplot(fig)
fig.show()

def grafBoxPlot(df, meso):
  N = 13     # Number of boxes

  # generate an array of rainbow colors by fixing the saturation and lightness of the HSL
  # representation of colour and marching around the hue.
  # Plotly accepts any CSS color format, see e.g. http://www.w3schools.com/cssref/css_colors_legal.asp.
  #c = ['hsl('+str(h)+',50%'+',50%)' for h in np.linspace(0, 360, N)]
  c= ["#696969","#696969", "#696969", "#696969", "#696969","#696969", "#696969", "#696969", "#696969","#696969", "#696969","#696969", "#696969"]
  # Each box is represented by a dict that contains the data, the type, and the colour.
  # Use list comprehension to describe N boxes, each with a different colour and with different randomly generated data:
  fig = go.Figure(data=[go.Box(
      y=filtrandoMesoEMes(bancoPrecipitacao,meso,i)["PRECIPITACAO"],
      marker_color=c[i], 
      name = inserirLabels(i)
      ) for i in range(int(N))])

  # format the layout
  fig.update_layout( plot_bgcolor = 'white', showlegend=False,# title = meso+' (1998-2020)',
      xaxis=dict(showgrid=True, zeroline=False,gridwidth=1,gridcolor='lightgray', linewidth=1, showline=True,  \
                 showticklabels=True, title="Meses",),
      yaxis=dict(zeroline=False,gridcolor='lightgray',gridwidth=1, linewidth=1, showline=True, title="Precipitação (mm)"),
      paper_bgcolor='rgb(255,255,255)', 
      font=dict( family="times new roman", size=30, color="black"),
      #plot_bgcolor='rgb(233,233,233)',
  )
  return fig.show()

grafBoxPlot(bancoPrecipitacao,"Sertão Pernambucano")

grafBoxPlot(bancoPrecipitacao,"São Francisco Pernambucano")

grafBoxPlot(bancoPrecipitacao,"Mata Pernambucana")

grafBoxPlot(bancoPrecipitacao,"Agreste Pernambucano")

grafBoxPlot(bancoPrecipitacao,"Metropolitana do Recife")

!pip install -U kaleido

import kaleido

import os

if not os.path.exists("images"):
    os.mkdir("images")

fig.write_image("images/fig1.pdf")

def inserirLabels(i):
  if i==1:
    return "Jan"
  
  elif i==2:
    return "Fev"
  
  elif i==3:
    return "Mar"
  
  elif i==4:
    return "Abr"
  
  elif i==5:
    return "Mai"

  elif i==6:
    return "Jun"
  
  elif i==7:
    return "Jul"
  
  elif i==8:
    return "Ago"
  
  elif i==9:
    return "Set"
  
  elif i==10:
    return "Out" 

  elif i==11:
    return "Nov" 

  else:
    return "Dez"

'''#definindo a função
def linear(t):
  return t
t = ["Jan","Fev","Mar","Abr","Mai","Jun","Jul","Ago","Set","Out","Nov","Dez"]
fig = go.Figure()
fig.add_trace(go.Scatter(x = bancoPrecipitacao["MES"], y = linear(bancoPrecipitacao["ANO"])))
fig.update_layout(title='Função Linear',
xaxis_title='t',
yaxis_title='f(t)', 
template = 'plotly_white') #adicionando o template
fig.show()'''

N=23
 

fig = go.Figure(data=[go.Scatter(
    y=filtrandoMesoEMes(bancoPrecipitacao,"Metropolitana do Recife",i)["PRECIPITACAO"],
    marker_color=c[i], 
    name = inserirLabels(i)
    ) for i in range(int(N))])

fig.add_trace(go.Scatter(x = t, y = [1998,1999,2000,2001,2002,2003,2004,2005,20], name = 'Função linear', mode = 'lines'))
fig.add_trace(go.Scatter(x = t, y = quadr(t), name = 'Função Quadrática', mode = 'lines'))
fig.add_trace(go.Scatter(x = t, y = cub(t), name = 'Função Cúbica', mode = 'lines'))
fig.update_layout(title='Comparando funções',
xaxis_title='t',
yaxis_title='f(t)',
plot_bgcolor = 'white',
font = {'family': 'Arial','size': 16,'color': 'black'},
colorway=px.colors.qualitative.Set2) #Adicionando a seq. de cores
fig.update_xaxes( showgrid=True, gridwidth=1, gridcolor='lightgray',
showline=True, linewidth=1, linecolor='black'
)
fig.update_yaxes(showgrid=True, gridwidth=1, gridcolor='lightgray',
showline=True, linewidth=1, linecolor='black')
fig.show()'''

def grafLinha(df, meso):
  N = 13     # Number of boxes

  # generate an array of rainbow colors by fixing the saturation and lightness of the HSL
  # representation of colour and marching around the hue.
  # Plotly accepts any CSS color format, see e.g. http://www.w3schools.com/cssref/css_colors_legal.asp.
  c = ['hsl('+str(h)+',50%'+',50%)' for h in np.linspace(0, 360, N)]

  # Each box is represented by a dict that contains the data, the type, and the colour.
  # Use list comprehension to describe N boxes, each with a different colour and with different randomly generated data:
  fig = go.Figure(data=[go.scatter(
      y=filtrandoMesoEMes(bancoPrecipitacao,meso,i)["PRECIPITACAO"],
      marker_color=c[i], 
      name = inserirLabels(i)
      ) for i in range(int(N))])

  # format the layout
  fig.update_layout(title = meso+' (1998-2020)',
      xaxis=dict(showgrid=False, zeroline=False, showticklabels=True, title="Meses"),
      yaxis=dict(zeroline=False, gridcolor='white', title="Precipitação (mm)"),
      paper_bgcolor='rgb(233,233,233)',
      plot_bgcolor='rgb(233,233,233)',
  )

  return fig.show()

grafLinha(bancoPrecipitacao,"Sertão Pernambucano")

bancoPrecipitacao["MESO_"].unique().tolist()

bancoPrecipitacao[(bancoPrecipitacao['MESO_'] =="Mata Pernambucana")]["PRECIPITACAO"]

(bancoPrecipitacao[(bancoPrecipitacao['MESO_'] =="Mata Pernambucana")].groupby(by=['ANO']).sum().groupby(level=[0]).cumsum()/230)

meses=bancoPrecipitacao["MES"].unique().tolist()
#anos=meses=bancoPrecipitacao["ANO"].unique().tolist()
from plotly.subplots import make_subplots

def mediaAnos(meso):
  listaAux=[]
  for i in range(1998,2021,1):
    listaAux.append(filtrandoMesoEAno(bancoPrecipitacao,meso,i)["PRECIPITACAO"].mean())
  return listaAux
mediaAnos('São Francisco Pernambucano' )

filtrandoMesoEAno(bancoPrecipitacao,'Sertão Pernambucano',1998)["PRECIPITACAO"].mean()

filtrandoMesoEAno(bancoPrecipitacao,"Sertão Pernambucano",1998)["PRECIPITACAO"].mean()

#gerando subplots
fig = make_subplots(rows=5, cols=1, subplot_titles = ("Sertão Pernambucano", "São Francisco Pernambucano", "Metropolitana do Recife","Agreste Pernambucano","Mata Pernambucana"))
fig.append_trace(go.Scatter(x = list(range(1998, 2023, 1)), y = mediaAnosSertao, name = 'Sertão Pernambucano', mode = 'lines'),row=1, col=1)
fig.append_trace(go.Scatter(x = t, y = bancoPrecipitacao[(bancoPrecipitacao['MESO_'] =="São Francisco Pernambucano")]["PRECIPITACAO"], name = 'São Francisco Pernambucano', mode = 'lines'),row=2, col=1)
fig.append_trace(go.Scatter(x = t, y = bancoPrecipitacao[(bancoPrecipitacao['MESO_'] =="Metropolitana do Recife")]["PRECIPITACAO"], name = 'Metropolitana do Recife', mode = 'lines'),row=3, col=1)
fig.append_trace(go.Scatter(x = t, y = bancoPrecipitacao[(bancoPrecipitacao['MESO_'] =="Agreste Pernambucano")]["PRECIPITACAO"], name = 'Agreste Pernambucano', mode = 'lines'),row=4, col=1)
fig.append_trace(go.Scatter(x = t, y = bancoPrecipitacao[(bancoPrecipitacao['MESO_'] =="Mata Pernambucana")]["PRECIPITACAO"], name = 'Mata Pernambucana', mode = 'lines'),row=5, col=1)
# Atualizando os eixos x
fig.update_xaxes( title_text = "Meses", showgrid=True, gridwidth=1, gridcolor='lightgray',showline=True, linewidth=1, linecolor='black', row = 1, col = 1)
fig.update_xaxes( title_text = "Meses", showgrid=True, gridwidth=1, gridcolor='lightgray',showline=True, linewidth=1, linecolor='black', row = 2, col = 1)
fig.update_xaxes( title_text = "Meses", showgrid=True, gridwidth=1, gridcolor='lightgray',showline=True, linewidth=1, linecolor='black', row = 3, col = 1)
fig.update_xaxes( title_text = "Meses", showgrid=True, gridwidth=1, gridcolor='lightgray',showline=True, linewidth=1, linecolor='black', row = 4, col = 1)
fig.update_xaxes( title_text = "Meses", showgrid=True, gridwidth=1, gridcolor='lightgray',showline=True, linewidth=1, linecolor='black', row = 5, col = 1)
# Atualizando os eixos y
fig.update_yaxes( title_text = "Precipitação (mm)", showgrid=True, gridwidth=1, gridcolor='lightgray',showline=True, linewidth=1, linecolor='black', row = 1, col = 1)
fig.update_yaxes( title_text = "Precipitação (mm)", showgrid=True, gridwidth=1, gridcolor='lightgray',showline=True, linewidth=1, linecolor='black', row = 2, col = 1)
fig.update_yaxes( title_text = "Precipitação (mm)", showgrid=True, gridwidth=1, gridcolor='lightgray',showline=True, linewidth=1, linecolor='black', row = 3, col = 1)
fig.update_yaxes( title_text = "Precipitação (mm)", showgrid=True, gridwidth=1, gridcolor='lightgray',showline=True, linewidth=1, linecolor='black', row = 4, col = 1)
fig.update_yaxes( title_text = "Precipitação (mm)", showgrid=True, gridwidth=1, gridcolor='lightgray',showline=True, linewidth=1, linecolor='black', row = 5, col = 1)
# o comando fig.update_layout nos permite alterar o layout do gráfico
fig.update_layout(plot_bgcolor = 'white',
font = {'family': 'Arial','size': 12,'color': 'black'},
colorway=["red", "green", "blue"])
fig.update_layout(height=1000, width=1000, title_text="1998")
fig.show()

fig = px.line( x="ANO", y=mediaAnosSertao)
              #hover_data={"date": "|%B %d, %Y"},
              #title='custom tick labels')
fig.show()

import plotly.express as px
'''dfLinhas = px.data.stocks()'''
fig = px.line(dfLinhas, x="ANOS", y=dfLinhas.columns, color_discrete_sequence=px.colors.qualitative.G10) #title='Evolução Temporal da Precipitação Média Anual no Estado de Pernambuco', )
fig.update_xaxes( title_text = "Anos", showgrid=True, gridwidth=1, gridcolor='lightgray',showline=True, linewidth=1, linecolor='black', row = 1, col = 1)
fig.update_yaxes( title_text = "Precipitação (mm)", showgrid=True, gridwidth=1, gridcolor='lightgray',showline=True, linewidth=1, linecolor='black', row = 1, col = 1)
fig.update_layout(plot_bgcolor = 'white', legend_title="Mesorregião" ,
font = {'family': 'times new roman','size': 30,'color': 'black'} )
#fig.update_traces(legendgrouptitle_font_color=["#e41a1c", "#377eb8", "#4daf4a", "#984ea3", "#ff7f00"], selector=dict(type='scatter'))
fig.show()

mediaAnos(listaAux, 'Sertão Pernambucano' )

len(mediaAnos(mediaAnosSertao, "São Francisco Pernambucano" ))

dfLinhas = pd.DataFrame()
dfLinhas

dfLinhas["Sertão Pernambucano"]=mediaAnos('Sertão Pernambucano' )
dfLinhas["São Francisco Pernambucano"]=mediaAnos('São Francisco Pernambucano' )
dfLinhas["Mata Pernambucana"]=mediaAnos( 'Mata Pernambucana' )
dfLinhas["Agreste Pernambucano"]=mediaAnos('Agreste Pernambucano' )
dfLinhas["Metropolitana do Recife"]=mediaAnos( 'Metropolitana do Recife' )
#dfLinhas["ANOS"]=list(range(1998, 2023, 1))
dfLinhas



dfLinhas["Sertão Pernambucano"]=mediaAnos('Sertão Pernambucano' )
dfLinhas["São Francisco Pernambucano"]=mediaAnos('São Francisco Pernambucano' )
dfLinhas["Mata Pernambucana"]=mediaAnos( 'Mata Pernambucana' )
dfLinhas["Agreste Pernambucano"]=mediaAnos('Agreste Pernambucano' )
dfLinhas["Metropolitana do Recife"]=mediaAnos( 'Metropolitana do Recife' )
#dfLinhas["ANOS"]=list(range(1998, 2023, 1))
dfLinhas

dfLinhas["ANOS"]=list(range(1998, 2021, 1))

dfLinhas

list(range(1998, 2021, 1))

dfLinhas["ANOS"]=[1998,1999,2000,2001,2002,2003,2004,2005,2006,2007,2008,2009,2010,2011,2012,2013,2014,2015,2016,2017,2018,2019,2020]

df_ = pd.merge(bancoPrecipitacao, quadricula_[['CODIGO','geometry']], left_on='codigo', right_on='CODIGO', how='outer')
df_

from matplotlib import pyplot as PLT
from matplotlib import cm as CM
from matplotlib import mlab as ML
import numpy as NP

n = 1e5
x = y = NP.linspace(-5, 5, 100)
X, Y = NP.meshgrid(x, y)
Z1 = ML.bivariate_normal(X, Y, 2, 2, 0, 0)
Z2 = ML.bivariate_normal(X, Y, 4, 1, 1, 1)
ZD = Z2 - Z1
x = X.ravel()
y = Y.ravel()
z = ZD.ravel()
gridsize=30
PLT.subplot(111)

# if 'bins=None', then color of each hexagon corresponds directly to its count
# 'C' is optional--it maps values to x-y coordinates; if 'C' is None (default) then 
# the result is a pure 2D histogram 

PLT.hexbin(x, y, C=z, gridsize=gridsize, cmap=CM.jet, bins=None)
PLT.axis([x.min(), x.max(), y.min(), y.max()])

cb = PLT.colorbar()
cb.set_label('mean value')
PLT.show()

# importando o banco da correlação
corrEstSat = pd.read_csv('/content/drive/My Drive/correlacaoEstacoesSatelite.csv',encoding="iso-8859-1", sep=",")

corrEstSat["CLASSI__"].unique()

filtro  = corrEstSat['CLASSI__'] == "Perfeita Negativa"
gorgetas_em_grupo = corrEstSat[filtro]
corrEstSat=corrEstSat["CLASSI__"].drop("Perfeita Negativa",axis=0) #excluir colunas desnecessarias

corrEstSat

corrEstSat.drop(corrEstSat.loc[corrEstSat['CLASSI__']=='Perfeita Negativa'].index, inplace=True) # Excluir determinada linha do df
corrEstSat["CLASSI__"].unique()

corrEstSat

corrEstSat['CLASSI__'].unique()

def numToStrInColumn(df,coluna,nomeDaNovaVariavel):
  listaDaNovaVariavel=[]
  df[coluna]=list(df[coluna].unique())
  for i in df[coluna]:
    listaDaNovaVariavel.append(str(i))
  
  # Excluindo coluna antiga
  df=df.drop(coluna,axis=1)
  df[nomeDaNovaVariavel]=listaDaNovaVariavel
  return df

numToStrInColumn(corrEstSat,'COD_EST','COD_EST_')

corrEstSat_

# Renomear a coluna do df
corrEstSat.rename(columns={'CLASSI__': 'Classificação'}, inplace=True) ##Renomear colunas

corrEstSat["Classificação"].unique()

# Gráfico de Barras da correlação
'''Syntax: plotly.express.bar(data_frame=None, x=None, y=None, color=None, facet_row=None, facet_col=None, facet_col_wrap=0, hover_name=None, hover_data=None, custom_data=None, text=None, error_x=None, error_x_minus=None, error_y=None, error_y_minus=None, animation_frame=None, animation_group=None, category_orders={}, labels={}, color_discrete_sequence=None, color_discrete_map={}, color_continuous_scale=None, range_color=None, color_continuous_midpoint=None, opacity=None, orientation=None, barmode=’relative’, log_x=False, log_y=False, range_x=None, range_y=None, title=None, template=None, width=None, height=None)'''


import plotly.express as px
import plotly

df1 = corrEstSat.groupby(["Classificação"]).count().reset_index()

fig = px.bar(df1,
             y=corrEstSat.groupby(["Classificação"]).size(),
             x="Classificação",
             color='Classificação',
             template='plotly_white',
             labels=dict(x="Classificação", y="Quantidade de Estações", color="Place"),text=[50,2,2,5,7],
             width=800, height=400
          )
fig.update_xaxes(title_font=dict(size=18 ))
fig.update_yaxes(title_font=dict(size=18))
fig.update_layout(showlegend=False)
fig.update_yaxes(showticklabels=False)
fig.show()

import kaleido
plotly.io.write_image(fig, 'lineBar_corr.pdf', format='pdf',validate=False, engine='kaleido') # Exportar imagem para pdf

pip install Kaleido fig.write_image("lineBar_corr.pdf")

!pip install -U kaleido
import kaleido

import os

if not os.path.exists("images"):
    os.mkdir("images")

fig.write_image("images/lineBar_corr.pdf")